#!/usr/bin/env python

from task_machine.StateMachine import * #StateMachine
import rospy
import time 
import datetime
import sys
def blocking_call(queue):
    try:
        args = queue.get()
        i =0
        print(str(datetime.datetime.now().time())+"\n"+ args+"\n")
        x = args[0]
        y = args[1]
        z = args[2]
        print(str(datetime.datetime.now().time())+"\n"+ "Z: ", z+"\n")
        while i < 100:
            x+=1
            y+=1
            z+=1
            time.sleep(1)
            i+=1
        print(str(datetime.datetime.now().time())+"\n"+ "computed: "+ str([x, y, z])+"\n")
        queue.put([x,y,z])
    finally:
        print(str(datetime.datetime.now().time())+"\n"+ "EXCEPTTTTTTTTTTTTTTTTTTTTT"+"\n")
    return

def start(cargo_in, event_in, event_out):
    print("\n"+ "----------"+"\n")
    print( "START"+"\n")
    print( "----------"+"\n")
    print("\t cargo: "+ str( cargo_in)+"\n")
    print("\t STATE_EVENT: "+ str( event_in.isSet())+"\n")
    print( ""+"\n")
    if event_in.isSet():
        event_out.set()
        print( ""+"\n")
        print( "set HOLD"+"\n")
        print( ""+"\n")
        return ("first_hold", "data required to hold")
    return ("move_to_human", ["Zdzisiu", None, False])
    
def move_to_human(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "move_to_human"+"\n")
    print("----------"+"\n")
    print( "\t args [<human_name>, <init_human_pose>, <is it a return call>]: "+ str( cargo_in)+"\n")
    print( "\t Get pose of the human "+"\n")
    i = 0
    while i < 10:
        print( "\t Moving to the human: "+ str( cargo_in[0])+"\n")
        print( "\t Checking if the destination is reached"+"\n")
    # run_blocking(blocking_call, cargo_in, event)
        if event_in.isSet():
            event_out.set()
            print( ""+"\n")
            print( "set HOLD"+"\n")
            print( ""+"\n")
            return ("hold_moving", "stop robot")
        time.sleep(1)
        i+=1
    return ("look_for_human", cargo_in)

def look_for_human(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "look_for_human"+"\n")
    print("----------"+"\n")
    print( "\t args [<human_name>, <init_human_pose>, <is a resume call>]: "+ str( cargo_in)+"\n")
    print( "\t Get pose of the human "+"\n")
    i = 0
    while i < 10:
        print( "\t Visiual search for human \n")
        if event_in.isSet():
            event_out.set()
            print( ""+"\n")
            print( "set HOLD"+"\n")
            print( ""+"\n")
            return ("hold_moving", "stop robot")
        time.sleep(1)
        i+=1
    if cargo_in[2]:
        return ("send_report", [cargo_in[0],None,cargo_in[1]])
    return ("check_consciousness", cargo_in)

def hold_moving(cargo_in):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print("hold_moving"+"\n")
    print( "----------"+"\n")
    print("\t args: "+ str( cargo_in)+"\n")
    # run_blocking(blocking_call, cargo_in, event)
    return ("move_to_human", ["Zdzisiu",[10,20], False])


def check_consciousness(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "check_consciousness"+"\n")
    print("----------"+"\n")
    say = "Hello! Mr "+cargo_in[0]+ "! Can you hear me? How do you feel?"
    response = "Uh! I fell, but I'm fine. Just need a hand to stand up."
    i=0
    print( "\t SAY_METHOD("+ str(say)+")\n")
    while i < 3:
        print( "\t Checking if the speech is over"+"\n")
    # run_blocking(blocking_call, cargo_in, event)
        if event_in.isSet():
            event_out.set()
            print( ""+"\n")
            print( "set HOLD"+"\n")
            print( ""+"\n")
            return ("hold_greet", "Oh! I'm sorry but I got very important request. Please wait, I'll come back")
        i+=1
        time.sleep(1)
    while i < 5:
        print( "\t Waiting for response "+"\n")
    # run_blocking(blocking_call, cargo_in, event)
        if event_in.isSet():
            event_out.set()
            print( ""+"\n")
            print( "set HOLD"+"\n")
            print( ""+"\n")
            return ("hold_greet", "Oh! I'm sorry but I got very important request. Please wait, I'll come back")
        i+=1
        time.sleep(1)
    response = "Uh! I fell, but I'm fine. Just need a hand to stand up."
    cargo_out = [cargo_in[0], response,[10,10]]
    return ("send_report", cargo_out)

def send_report(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "send_report"+"\n")
    print("----------"+"\n")
    print( "\t args <human_name, human response, human pose>: "+ str( cargo_in)+"\n")
    # if the response is None, it is a return call and the old report was saved
    if cargo_in[1] == None:
        print( "Loading previous report"+"\n")
    i = 0
    while i < 3:
        print( "\t Preparing and sending report"+")\n")
        print( "\t HOLD IS UNAVAILABLE"+"\n")
        i+=1
        time.sleep(1)
    return ("wait_for_acceptance", cargo_in[1]) 

def wait_for_acceptance(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "wait_for_acceptance"+"\n")
    print("----------"+"\n")
    print( "\t args <human pose>: "+ str( cargo_in)+"\n")
    i = 0
    while i < 3:
        print( "\t Waiting 3 secs for the report acceptance, after this time the task will be held"+")\n")
        print( "\t HOLD IS UNAVAILABLE"+"\n")
        i+=1
        time.sleep(1)
    got_acceptance = True
    to_teleop = True
    if got_acceptance and not to_teleop:
        return ("goodbye_human", None) 
    if to_teleop:
        return ("teleop", None) 
    else:
        event_out.set()
        print ("I got no response from care giver. I'll be back If there will be necessity")
        print ("Saving the report")
        return ("hold_wait_for_acceptance", cargo_in) 

def hold_wait_for_acceptance(cargo_in):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "hold_wait_for_acceptance"+"\n")
    print("----------"+"\n")
    print( "\t args <human pose>: "+ str( cargo_in)+"\n")
    human_name = "Zdzisiu"
    cargo_out = [human_name, cargo_in]
    return ("return_on_acceptance", cargo_out)
   
def return_on_acceptance(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "return_on_acceptance"+"\n")
    print("----------"+"\n")
    print( "\t args <human_name, init_human_pose, return_scenario>: "+ str( cargo_in)+"\n")
    human_name = "Zdzisiu"
    cargo_out = [human_name, cargo_in, True]
    if cargo_in[2] == 0:
        return ("finish", None)
    if cargo_in[2] == 1:
        return ("move_to_human", cargo_out)
    else:
        return ("finish", None)

def teleop(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "teleop"+"\n")
    print("----------"+"\n")
    print( "\t args <None>: "+ str( cargo_in)+"\n")
    i = 0
    teleoper_decision = None
    # czekaj aż człowiek da sygnał o zakończeniu teleop
    while i < 10:
        k=0
        print( "\t Human is teleoping the robot\n")
        if event_in.isSet() and teleoper_decision != "dont_interrupt":
            print( ""+"\n")
            print( "got HOLD"+"\n")
            print( "sending the interruption request to teleoper"+"\n")
            print( "Waiting for the teleoper to decide if the interruption should be performed\n")
            print( "Allowed answers:\n")
            print("\t dont_interrupt\n")
            print("\t interrupt_and_not_return\n")
            print("\t interrupt_and_return\n")
            while k < 4:
                print(str(k))
                k=k+1
                teleoper_decision = "dont_interrupt"
            print "TELEOPER said: "+str(teleoper_decision)
            if teleoper_decision = "interrupt_and_not_return":
                event_out.set()
                return ("final", None)
            if teleoper_decision = "interrupt_and_return":
                event_out.set()
                return ("hold_teleop", [10,20])
            if teleoper_decision = "dont_interrupt":
                pass
        i+=1
        time.sleep(1)
    return ("goodbye_human", None)
#TO DO!
def hold_teleop(cargo_in):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "hold_teleop"+"\n")
    print("----------"+"\n")
    say = "I got new task, I'll be back and the care giver will contact you later on"
    print( "\t SAY_METHOD("+ str( say)+")\n")
    return ("return_on_acceptance", ["Zdzisiu", [1,2], True])

#TO DO!
def hold_greet(cargo_in):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "SAY"+"\n")
    print("----------"+"\n")
    print( "\t SAY_METHOD("+ str( cargo_in)+")\n")
    return ("move_to_human", [1,2])

def guide_human(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "guide_human"+"\n")
    print("----------"+"\n")
    print( "\t args <destination>: "+ str( cargo_in)+"\n")
    i = 0
    while i < 10:
        print( "\t Moving to the destination: "+ str( cargo_in)+"\n")
        print( "\t Checking if the human is following me"+"\n")
        if event_in.isSet():
            event_out.set()
            print( ""+"\n")
            print( "set HOLD"+"\n")
            print( ""+"\n")
            return ("hold_guide", None)
        i+=1
        time.sleep(1)
    return ("goodbye_human", None)

def hold_guide(cargo_in):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print("hold_guide"+"\n")
    print( "----------"+"\n")
    print("\t args: "+ str( cargo_in)+"\n")
    print( "\t Approaching human "+"\n")
    print( "\t SAY_METHOD("+ "Oh! I'm sorry but I got a very important request. Please wait, I'll come back"+")\n")
    print( "\t Go aside "+"\n")
    return ("move_to_human", ["Zdzisiu",[10,20]])

def goodbye_human(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "goodbye_human"+"\n")
    print("----------"+"\n")
    print( "\t args <destination>: "+ str( cargo_in)+"\n")
    print( "\t SAY_METHOD("+ "My task is finished, goodbye"+")\n")
    i = 0
    while i < 5:
        print( "\t Checking if the speech is over"+"\n")
        print( "\t HOLD IS UNAVAILABLE"+"\n")

        i+=1
        time.sleep(1)
    return ("go_to_dock", None)

def go_to_dock(cargo_in, event_in, event_out):
    print(str(datetime.datetime.now().time())+"\n"+ "----------"+"\n")
    print( "go_to_dock"+"\n")
    print("----------"+"\n")
    print( "\t args: "+ str( cargo_in)+"\n")
    i = 0
    while i < 5:
        print( "\t Moving to my dock"+")\n")
        if event_in.isSet():
            event_out.set()
            print( ""+"\n")
            print( "set HOLD"+"\n")
            print( ""+"\n")
            return ("final", None)
        i+=1
        time.sleep(1)
    return ("final", None) 

def final(cargo_in):
    return

if __name__== "__main__":
    try:
        rospy.init_node("human_fell", anonymous=True)
        f1=open('./blockin_log', 'w+')
        f2=open('./state_m_log', 'w+')
        m = StateMachine(f2)
        m.add_state("Start", start, None)
        m.add_state("move_to_human", move_to_human, None)
        m.add_state("look_for_human", look_for_human, None)
        m.add_state("check_consciousness", check_consciousness, None)
        m.add_state("send_report", send_report, None)
        m.add_state("wait_for_acceptance", wait_for_acceptance, None)
        m.add_state("hold_wait_for_acceptance", hold_wait_for_acceptance, None)
        m.add_state("go_to_dock", go_to_dock, None)
        m.add_state("teleop", teleop, None)
        m.add_state("final", final, end_state=True)
        m.add_state("hold_greet", hold_greet, None)
        m.add_state("hold_moving", hold_moving, None)
        m.set_start("Start")
        m.run("Python is great")
    #m.run("Python is difficult")
    #m.run("Perl is ugly")
    finally:
        f2.close()
        f1.close()